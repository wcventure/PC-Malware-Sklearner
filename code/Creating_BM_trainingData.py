# -*- coding: utf-8 -*-
import re
import sys
import os
import pickle
import numpy as np
from collections import Counter
from os import listdir
from os.path import isfile, join

##################################################################################################################
def hasNumbers(inputString):
    return any(char.isdigit() for char in inputString)

def InfoExtraction(f, codeset=set(), dllset=set()):

    cnt = Counter()
    dlllist = []
    idataVarSizeArray = np.zeros(32)

    Context = f.readlines()
    for i,line in enumerate(Context):
        if len(line) < 18:  # Bullshit line
            continue

        line = line.replace(' ','\t',1) # Compatibility format

        if '.text:' == line[0:6] or 'CODE:' == line[0:5] or 'seg' == line[0:3]:
            if ' ptr ' in line and '=' in line:
                if '=' != line.split('\t')[-1].strip()[0]:
                    txt = '1'+line.split('\t')[-1].strip()
                else:
                    txt = '1'+line.split('\t')[-2].strip() + ' ' + line.split('\t')[-1].strip()  # Only keep the assembly part and not everything on the left
            else:
                txt = line.split('\t')[-1].strip()  # Only keep the assembly part and not everything on the left

            uselessflag = 0
            if re.search('^;', txt):  # Most likely a comment
                uselessflag = 1
            if 'db' in txt:  # Painful to watch
                uselessflag = 1
            if 'dd' in txt:  # Painful to watch
                uselessflag = 1
            if 'align' in txt:  # Painful to watch
                uselessflag = 1
            if 'proc near' in txt or 'endp' in txt:
                uselessflag = 1
            if 'sub_' in txt or 'loc_' in txt:
                uselessflag = 1
            if '(' in txt or ')' in txt:
                uselessflag = 1

            element = txt.split(' ')
            # Trying to only keep basic instructions like: mov, lea, jmp, etc..

            if uselessflag==0 and len(element[0]) < 6 and not hasNumbers(element[0]) and not re.search('[ 0123456789/?%":\|\.\*_\(\)\[\]]', element[0]) and element[0].strip() != '':
                if element[0] == 'dw' or element[0] == 'TO' or element[0] == 'extrn' or element[0] == 'PRESS':
                    continue
                else:
                    codeset.add(element[0])
                    cnt[element[0]] += 1

        if '.data:' == line[0:6]:
            if '; DATA XREF:' in line:
                idataNameMat = re.search('([_\w]+)[ \t]+(db|dw|dd)[ \t]+\w+',line)
                if idataNameMat:
                    #print(idataNameMat.groups()[0])
                    #print(idataNameMat.group())

                    if re.search('([_\w]+)[ \t]+db[ \t]+\w+',line):
                        idataVarSize = 1
                    elif re.search('([_\w]+)[ \t]+dw[ \t]+\w+',line):
                        idataVarSize = 2
                    elif re.search('([_\w]+)[ \t]+dd[ \t]+\w+', line):
                        idataVarSize = 4

                    for k in range(1,33):
                        #检查文本有没有超出范围
                        if i+k+1 > len(Context):
                            break

                        #各种条件
                        if 'db' not in Context[i+k] and 'dw' not in Context[i+k] and 'dd' not in Context[i+k]:
                            #uslessLine
                            continue
                        if '; DATA XREF:' in Context[i+k]:
                            break
                        if 'align' in Context[i+k] or 'ends' in Context[i+k]:
                            break
                        if k==32:
                            idataVarSize = k
                            break

                        if re.search('([_\w]+)[ \t]+db[ \t]+\w+', Context[i+k]):
                            idataVarSize = idataVarSize + 1
                        elif re.search('([_\w]+)[ \t]+dw[ \t]+\w+', Context[i+k]):
                            idataVarSize = idataVarSize + 2
                        elif re.search('([_\w]+)[ \t]+dd[ \t]+\w+', Context[i+k]):
                            idataVarSize = idataVarSize + 4

                        if idataVarSize > 32:
                            idataVarSize = 32
                            break

                    #print(idataVarSize)
                    idataVarSizeArray[idataVarSize-1] = idataVarSizeArray[idataVarSize-1] + 1

        if '.idata:' == line[0:7]:
            importMat = re.search('Imports from' + '(.+)', line)
            if importMat:
                dllset.add(importMat.groups()[0].strip())
                dlllist.append(importMat.groups()[0].strip())

    return cnt, idataVarSizeArray , dlllist

##################################################################################################################

benginPath = "Benign_ML_set/train/"
malwarePath = "Malware_ML_Set/train/"

list_bengin_files = [f for f in listdir(benginPath) if isfile(join(benginPath, f))]
list_malware_files = [f for f in listdir(malwarePath) if isfile(join(malwarePath, f))]
set_bengin_files = set([os.path.splitext(el)[0] for el in list_bengin_files])
set_malware_files = set([os.path.splitext(el)[0] for el in list_malware_files])

benginId_list = list(set_bengin_files)
malwareId_list = list(set_malware_files)

nb_sample = len(benginId_list) + len(malwareId_list)
X = [0] * nb_sample
Y = np.array([0]*len(benginId_list) + [1]*len(malwareId_list))
LineC = [0] * nb_sample
dllcollect = [0] * nb_sample
idataVSize = np.zeros((nb_sample, 32))

s_word = set()
dllset = set()

for i, benginId in enumerate(benginId_list):

    f = open(benginPath + benginId + '.asm', 'r', encoding='utf-8')
    print('benign:', benginId, 'num = ', i, '/',  len(benginId_list))

    X[i] , idataVSize[i] , dllcollect[i] = InfoExtraction(f, s_word ,dllset)

    if not i % 10:
        sys.stdout.write("\r%d / %d \n" % (i, len(s_word)))
        sys.stdout.flush()

    f.close()

for i, malwareId in enumerate(malwareId_list):

    f = open(malwarePath + malwareId + '.asm', 'r', encoding='utf-8')
    print('malware:', malwareId, 'num = ', i, '/',  len(malwareId_list))

    X[i+len(benginId_list)] , idataVSize[i+len(benginId_list)] , dllcollect[i+len(benginId_list)] = InfoExtraction(f, s_word ,dllset)

    if not i % 10:
        sys.stdout.write("\r%d / %d \n" % (i, len(s_word)))
        sys.stdout.flush()

    f.close()


sys.stdout.write("\r%d" % i)
sys.stdout.flush()




outfile1 = open('BMsave\set_word_asm', 'w+b')
pickle.dump(s_word, outfile1)
outfile1.close()

outfile1 = open('BMsave\X_data_asm', 'w+b')
pickle.dump(X, outfile1)
outfile1.close()

outfile1 = open('BMsave\Y_data_asm', 'w+b')
pickle.dump(Y, outfile1)
outfile1.close()

outfile1 = open('BMsave\idataVSize', 'w+b')
pickle.dump(idataVSize, outfile1)
outfile1.close()

outfile1 = open('BMsave\dllset', 'w+b')
pickle.dump(dllset, outfile1)
outfile1.close()

outfile1 = open('BMsave\dllcollect', 'w+b')
pickle.dump(dllcollect, outfile1)
outfile1.close()

#print(s_word)
#print(X)