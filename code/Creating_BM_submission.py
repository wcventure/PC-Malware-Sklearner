# -*- coding: utf-8 -*-
import matplotlib.pyplot as plt
from os import listdir
from os.path import isfile, join

from sklearn.metrics import log_loss, confusion_matrix
from sklearn.model_selection import cross_val_score, KFold
from sklearn.preprocessing import scale, MinMaxScaler
from sklearn.linear_model import SGDClassifier
from sklearn.externals import joblib
from sklearn.metrics import accuracy_score
from sklearn.metrics import classification_report
from collections import Counter
from sklearn import tree
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.ensemble import RandomForestClassifier
from sklearn.naive_bayes import MultinomialNB
from sklearn.naive_bayes import BernoulliNB

import numpy as np
import os
import pickle
import re
import time
##################################################################################################################
lineTypeList = ['HEADER','.text','.rsrc','.rdata','.data','CODE','DATA','.bss','BSS','idata']

def hasNumbers(inputString):
    return any(char.isdigit() for char in inputString)

def InfoExtraction(f, codeset=set(), dllset=set()):

    cnt = Counter()
    dlllist = []
    idataVarSizeArray = np.zeros(32)
    lineTypeArray = np.zeros(len(lineTypeList))

    Context = f.readlines()
    for i,line in enumerate(Context):
        if len(line) < 18:  # Bullshit line
            continue

        line = line.replace(' ','\t',1) # Compatibility format

        if '.text:' == line[0:6] or 'CODE:' == line[0:5] or 'seg' == line[0:3]:
            if ' ptr ' in line and '=' in line:
                if '=' != line.split('\t')[-1].strip()[0]:
                    txt = '1'+line.split('\t')[-1].strip()
                else:
                    txt = '1'+line.split('\t')[-2].strip() + ' ' + line.split('\t')[-1].strip()  # Only keep the assembly part and not everything on the left
            else:
                txt = line.split('\t')[-1].strip()  # Only keep the assembly part and not everything on the left

            uselessflag = 0
            if re.search('^;', txt):  # Most likely a comment
                uselessflag = 1
            if 'db' in txt:  # Painful to watch
                uselessflag = 1
            if 'dd' in txt:  # Painful to watch
                uselessflag = 1
            if 'align' in txt:  # Painful to watch
                uselessflag = 1
            if 'proc near' in txt or 'endp' in txt:
                uselessflag = 1
            if 'sub_' in txt or 'loc_' in txt:
                uselessflag = 1
            if '(' in txt or ')' in txt:
                uselessflag = 1

            element = txt.split(' ')
            # Trying to only keep basic instructions like: mov, lea, jmp, etc..

            if uselessflag==0 and len(element[0]) < 6 and not hasNumbers(element[0]) and not re.search('[ 0123456789/?%":\|\.\*_\(\)\[\]]', element[0]) and element[0].strip() != '':
                if element[0] == 'dw' or element[0] == 'TO' or element[0] == 'extrn' or element[0] == 'PRESS':
                    continue
                else:
                    codeset.add(element[0])
                    cnt[element[0]] += 1

        if '.data:' == line[0:6]:
            if '; DATA XREF:' in line:
                idataNameMat = re.search('([_\w]+)[ \t]+(db|dw|dd)[ \t]+\w+',line)
                if idataNameMat:
                    #print(idataNameMat.groups()[0])
                    #print(idataNameMat.group())

                    if re.search('([_\w]+)[ \t]+db[ \t]+\w+',line):
                        idataVarSize = 1
                    elif re.search('([_\w]+)[ \t]+dw[ \t]+\w+',line):
                        idataVarSize = 2
                    elif re.search('([_\w]+)[ \t]+dd[ \t]+\w+', line):
                        idataVarSize = 4

                    for k in range(1,33):
                        #检查文本有没有超出范围
                        if i+k+1 > len(Context):
                            break

                        #各种条件
                        if 'db' not in Context[i+k] and 'dw' not in Context[i+k] and 'dd' not in Context[i+k]:
                            #uslessLine
                            continue
                        if '; DATA XREF:' in Context[i+k]:
                            break
                        if 'align' in Context[i+k] or 'ends' in Context[i+k]:
                            break
                        if k==32:
                            idataVarSize = k
                            break

                        if re.search('([_\w]+)[ \t]+db[ \t]+\w+', Context[i+k]):
                            idataVarSize = idataVarSize + 1
                        elif re.search('([_\w]+)[ \t]+dw[ \t]+\w+', Context[i+k]):
                            idataVarSize = idataVarSize + 2
                        elif re.search('([_\w]+)[ \t]+dd[ \t]+\w+', Context[i+k]):
                            idataVarSize = idataVarSize + 4

                        if idataVarSize > 32:
                            idataVarSize = 32
                            break

                    #print(idataVarSize)
                    idataVarSizeArray[idataVarSize-1] = idataVarSizeArray[idataVarSize-1] + 1

        if '.idata:' == line[0:7]:
            importMat = re.search('Imports from' + '(.+)', line)
            if importMat:
                dllset.add(importMat.groups()[0].strip())
                dlllist.append(importMat.groups()[0].strip())

        #count line
        for j,eachLineType in enumerate(lineTypeList):
            if re.search('^'+eachLineType,line):
                lineTypeArray[j] = lineTypeArray[j] + 1
                break


    return cnt, idataVarSizeArray , lineTypeArray , dlllist

##################################################################################################################
benginPath = "Benign_ML_set/test/"
malwarePath = "Malware_ML_Set/test/"

list_bengin_files = [f for f in listdir(benginPath) if isfile(join(benginPath, f))]
list_malware_files = [f for f in listdir(malwarePath) if isfile(join(malwarePath, f))]
set_bengin_files = set([os.path.splitext(el)[0] for el in list_bengin_files])
set_malware_files = set([os.path.splitext(el)[0] for el in list_malware_files])

benginId_list = list(set_bengin_files)
malwareId_list = list(set_malware_files)

s_word_asm = pickle.load(open("BMsave/set_word_asm", "r+b"))
dllset = pickle.load(open('BMsave/dllset', 'r+b'))
dict_s = pickle.load(open("BMsave/dict_s_asm", "r+b"))
dict_dll = pickle.load(open("BMsave/dict_dll", "r+b"))

Id_list = benginId_list + malwareId_list
Y = np.array([0]*len(benginId_list) + [1]*len(malwareId_list))
X_test = np.zeros((len(Id_list), len(s_word_asm) + len(dllset) + 32) )

start = time.clock()  # 计算时间
for i, Id in enumerate(Id_list):

    if i<len(benginId_list):
        f = open(benginPath + Id + '.asm', 'r', encoding = 'utf-8')
    else:
        f = open(malwarePath + Id + '.asm', 'r', encoding='utf-8')
    print(Id, 'num = ',i+1, '/',len(Id_list))

    cnt , idataVSize , LineC , dlllist= InfoExtraction(f)

    for el in cnt:
        if el in s_word_asm:
            X_test[i][dict_s[el]] = cnt[el]

    if dlllist!=[]:
        for each in dlllist:
            if each in dict_dll:
                X_test[i][len(s_word_asm) + dict_dll[each]] = 1

    for j in range(0,32):
        X_test[i][len(s_word_asm) + len(dllset) + j] = idataVSize[j]  # idataVariable size
end = time.clock()  # 计算时间
print('\nfeature extraction time:', end - start,end='\n\n\n')

clf = joblib.load("BMsave/clf_model.m")
min_max_scaler = joblib.load("BMsave/min_max_scaler.m")

X_test = np.log(X_test + 1)
X_test = min_max_scaler.transform(X_test)


joblib.dump(X_test, "tempSave")
joblib.dump(Y, "tempSaveY")
print('Saved',end='\n\n\n')

X_test = joblib.load("tempSave")
Y = joblib.load("tempSaveY")

clf = joblib.load("BMsave/clf_model.m")


start = time.clock()  # 计算时间
result = clf.predict_proba(X_test)
label = clf.predict(X_test)
end = time.clock()  # 计算时间
print('\nTesting time:', end - start,end='\n\n\n')


w = open("submission.csv", "w")
w.write('"Id","bengin",')
w.write('"malware"\n')

assert (len(Id_list) == X_test.shape[0])

for i, sample in enumerate(result):
    string = '"%s",%s\n' % (Id_list[i], ','.join(map(str, sample)))
    w.write(string)

w.close()

print('Creating submission Finish！')


###输出混淆矩阵###
print('loss = ',end='')
print ("%.3f" % log_loss(Y, result))
print('accuracy = ',end='')
print(accuracy_score(Y, label))

cm = confusion_matrix(Y, label)
print(classification_report(Y, label))
print(cm)



